<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>360 Scene Editor</title>
  <!-- Add Font Awesome for remote module -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      touch-action: none;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .hamburger-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      border: none;
      color: white;
      font-size: 24px;
      width: 40px;
      height: 40px;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s, opacity 0.3s;
      opacity: 1;
      pointer-events: auto;
      touch-action: manipulation;
    }

    .hamburger-btn.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .hamburger-btn:hover,
    .hamburger-btn:active {
      background: rgba(0, 0, 0, 0.9);
    }

    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      width: 280px;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index: 90;
      overflow-y: auto;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
    }

    .sidebar.open {
      transform: translateX(0);
    }

    .sidebar-header {
      padding: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .sidebar-title {
      color: white;
      font-size: 18px;
      font-weight: 600;
      margin: 0;
    }

    .sidebar-close {
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      touch-action: manipulation;
    }

    .scenes-list {
      padding: 0;
      margin: 0;
    }

    .scene-item {
      padding: 15px 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      cursor: pointer;
      color: rgba(255, 255, 255, 0.7);
      transition: all 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
      touch-action: manipulation;
    }

    .scene-item:hover {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .scene-item.active {
      background: rgba(66, 165, 245, 0.2);
      color: #42a5f5;
      border-left: 3px solid #42a5f5;
      padding-left: 17px;
    }

    .scene-name {
      flex: 1;
    }

    /* Modal styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 200;
      justify-content: center;
      align-items: center;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal {
      background: #1e1e1e;
      border-radius: 8px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      font-size: 20px;
      font-weight: 600;
      color: white;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-close {
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      font-size: 24px;
      cursor: pointer;
      touch-action: manipulation;
    }

    .modal-close:hover {
      color: white;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .form-input,
    .form-file {
      width: 100%;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: white;
      font-size: 14px;
      box-sizing: border-box;
    }

    .form-input:focus,
    .form-file:focus {
      outline: none;
      border-color: #42a5f5;
      background: rgba(255, 255, 255, 0.15);
    }

    .form-file {
      padding: 8px;
      cursor: pointer;
    }

    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 30px;
    }

    .btn {
      flex: 1;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      touch-action: manipulation;
    }

    .btn-primary {
      background: #42a5f5;
      color: white;
    }

    .btn-primary:hover,
    .btn-primary:active {
      background: #2196F3;
    }

    .btn-primary:disabled {
      background: rgba(66, 165, 245, 0.5);
      cursor: not-allowed;
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .btn-secondary:hover,
    .btn-secondary:active {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn-danger {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .btn-danger:hover,
    .btn-danger:active {
      background: rgba(244, 67, 54, 0.3);
    }

    .manage-scenes-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .manage-scene-item {
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .manage-scene-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .manage-scene-name {
      color: white;
      font-weight: 500;
    }

    .manage-scene-input {
      width: 100%;
      padding: 6px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: white;
      font-size: 12px;
    }

    .manage-scene-input:focus {
      outline: none;
      border-color: #42a5f5;
    }

    .manage-scene-actions {
      display: flex;
      gap: 8px;
    }

    .btn-small {
      padding: 6px 12px;
      font-size: 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      touch-action: manipulation;
    }

    .btn-small-rename {
      background: rgba(66, 165, 245, 0.2);
      color: #42a5f5;
    }

    .btn-small-rename:hover,
    .btn-small-rename:active {
      background: rgba(66, 165, 245, 0.3);
    }

    .btn-small-delete {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .btn-small-delete:hover,
    .btn-small-delete:active {
      background: rgba(244, 67, 54, 0.3);
    }

    .no-scenes-message {
      color: rgba(255, 255, 255, 0.5);
      text-align: center;
      padding: 20px;
      font-size: 14px;
    }

    /* Scene selection popup styles */
    .scene-selection-popup {
      position: fixed;
      background: rgba(0, 0, 0, 0.95);
      border-radius: 8px;
      padding: 15px;
      z-index: 1000;
      display: none;
      flex-direction: column;
      gap: 8px;
      max-width: 250px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .scene-selection-popup.show {
      display: flex;
    }

    .scene-selection-header {
      color: white;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 5px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .scene-selection-item {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      color: rgba(255, 255, 255, 0.8);
      cursor: pointer;
      transition: all 0.2s;
      font-size: 13px;
      border: 1px solid transparent;
    }

    .scene-selection-item:hover {
      background: rgba(66, 165, 245, 0.2);
      color: #42a5f5;
      border-color: rgba(66, 165, 245, 0.3);
    }

    .scene-selection-close {
      position: absolute;
      top: 5px;
      right: 5px;
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      font-size: 16px;
      cursor: pointer;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
    }

    .scene-selection-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    /* Scene selection indicator */
    .scene-selection-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(66, 165, 245, 0.2);
      color: #42a5f5;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      z-index: 100;
      display: none;
      border: 1px solid rgba(66, 165, 245, 0.3);
    }

    .scene-selection-indicator.show {
      display: block;
    }

    /* Remote Mode Indicator */
    .remote-mode-indicator {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 193, 7, 0.2);
      color: #FFC107;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      z-index: 100;
      display: none;
      border: 1px solid rgba(255, 193, 7, 0.3);
    }

    .remote-mode-indicator.show {
      display: block;
    }

    /* REMOTE CONTAINER STYLES */
    .remote-container {
      position: fixed;
      z-index: 50;
      transform: translate(-50%, -50%);
      pointer-events: auto;
    }

    .remote-main-button {
      width: 50px;
      height: 50px;
      background-color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s;
      -webkit-tap-highlight-color: transparent;
      padding: 0;
    }

    .remote-main-button i {
      font-size: 14px;
      color: #333;
    }

    .remote-main-button:active {
      transform: scale(0.95);
    }

    .remote-main-button.active-main {
      box-shadow: 0 0 15px 5px rgba(255, 193, 7, 0.6);
      border: 1px solid rgba(255, 193, 7, 0.3);
    }

    .remote-main-button.active-main i {
      color: #FFC107;
    }

    /* REMOTE MODAL STYLES */
    /* Prevent text selection */
    .remote-container * {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: manipulation;
    }

    .remote-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }

    .remote-modal.show {
      display: flex;
    }

    .remote-modal-content {
      background-color: white;
      padding: 30px;
      margin: 0 10px;
      border-radius: 12px;
      width: 450px;
      max-width: 90%;
      min-width: 280px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
      position: relative;
      z-index: 2001;
    }

    @media (max-width: 768px) {
      .remote-modal-content {
        padding: 20px;
        min-width: 280px;
        max-width: 95%;
        max-height: 90vh;
        -webkit-overflow-scrolling: touch;
      }
    }

    .remote-modal-title {
      text-align: center;
      margin-bottom: 25px;
      color: #333;
      font-size: 18px;
      font-weight: bold;
    }

    .remote-switch-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 20px;
      margin-top: 20px;
    }

    @media (max-width: 768px) {
      .remote-switch-grid {
        gap: 15px;
      }
    }

    .remote-switch-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .remote-switch-button {
      background-color: white;
      padding: 8px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      transition: all 0.15s ease;
      width: 50px;
      height: 50px;
      position: relative;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      -webkit-appearance: none;
    }

    @media (max-width: 768px) {
      .remote-switch-button {
        width: 50px;
        height: 50px;
        padding: 10px;
      }
    }

    /* Better feedback for touch devices */
    @media (hover: none) and (pointer: coarse) {
      .remote-switch-button:active {
        transform: scale(0.95) !important;
        opacity: 0.8 !important;
        transition: transform 0.1s, opacity 0.1s !important;
      }
    }

    @media (hover: hover) and (pointer: fine) {
      .remote-switch-button:hover {
        transform: scale(1.05);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      }
    }

    .remote-switch-button i {
      font-size: 15px;
      color: #333;
      transition: color 0.15s;
    }

    /* ACTIVE STATE - YELLOW GLOW & ICON */
    .remote-switch-button.active i {
      color: #FFC107 !important;
    }

    .remote-switch-button.active {
      box-shadow: 0 0 15px 5px rgba(255, 193, 7, 0.7),
        0 2px 5px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.4);
      background-color: rgba(255, 193, 7, 0.08);
    }

    @media (hover: hover) and (pointer: fine) {
      .remote-switch-button.active:hover {
        box-shadow: 0 0 20px 8px rgba(255, 193, 7, 0.9),
          0 3px 8px rgba(0, 0, 0, 0.15);
        transform: scale(1.08);
      }
    }

    /* INACTIVE STATE - NO GLOW, BLACK ICON */
    .remote-switch-button:not(.active) i {
      color: #333 !important;
    }

    .remote-switch-button:not(.active) {
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      border: 1px solid transparent;
      background-color: white;
    }

    .remote-switch-label {
      font-size: 12px;
      color: #666;
      text-align: center;
      margin-top: 5px;
    }

    .remote-close-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #333;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      z-index: 2002;
    }

    .remote-close-btn:hover {
      background-color: #f0f0f0;
    }

    /* Edit Modal Styles */
    .remote-edit-modal {
      display: none;
    }

    .remote-edit-modal.show {
      display: flex;
    }

    .remote-edit-form {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .remote-form-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .remote-form-label {
      font-size: 14px;
      color: #333;
      font-weight: 500;
    }

    .remote-form-input {
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
    }

    .remote-form-input:focus {
      outline: none;
      border-color: #FFC107;
      box-shadow: 0 0 5px rgba(255, 193, 7, 0.3);
    }

    .remote-form-note {
      font-size: 12px;
      color: #888;
    }

    /* Icon Selection Styles */
    .remote-icon-selection {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
    }

    .remote-icon-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .remote-icon-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      border: 2px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .remote-icon-option:hover {
      background-color: #f5f5f5;
    }

    .remote-icon-option.selected {
      border-color: #FFC107;
      background-color: rgba(255, 193, 7, 0.05);
      box-shadow: 0 0 8px rgba(255, 193, 7, 0.3);
    }

    .remote-icon-option i {
      font-size: 24px;
      color: #333;
      margin-bottom: 5px;
    }

    .remote-icon-name {
      font-size: 10px;
      color: #666;
      text-align: center;
      word-break: break-all;
    }

    .remote-form-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
    }

    .remote-form-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .remote-form-btn.save {
      background-color: #FFC107;
      color: #333;
    }

    .remote-form-btn.save:hover {
      background-color: #FFB300;
      box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
    }

    .remote-form-btn.cancel {
      background-color: #f0f0f0;
      color: #333;
    }

    .remote-form-btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }
  </style>
</head>

<body>

  <!-- Hamburger menu button -->
  <button class="hamburger-btn" id="hamburgerBtn" title="Toggle menu">☰</button>
  <!-- Remote Mode Indicator -->
  <div class="remote-mode-indicator" id="remoteModeIndicator">
    Remote Placement Mode Active - Click to place remote
  </div>
  <!-- Scene selection indicator -->
  <div class="scene-selection-indicator" id="sceneSelectionIndicator">
    Scene Selection Mode Active - Click on a hotspot
  </div>

  <!-- Sidebar with scenes list -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h2 class="sidebar-title">Scenes</h2>
      <button class="sidebar-close" id="sidebarClose">✕</button>
    </div>
    <ul class="scenes-list" id="scenesList"></ul>
  </div>

  <!-- Scene selection popup -->
  <div class="scene-selection-popup" id="sceneSelectionPopup">
    <button class="scene-selection-close" id="sceneSelectionClose">✕</button>
    <div class="scene-selection-header">Select Target Scene</div>
    <div id="sceneSelectionList"></div>
  </div>

  <!-- Create scene modal -->
  <div class="modal-overlay" id="createSceneModal">
    <div class="modal">
      <div class="modal-header">
        <span>Create New Scene</span>
        <button class="modal-close" id="createSceneClose">✕</button>
      </div>
      <div class="form-group">
        <label class="form-label">Scene Name</label>
        <input type="text" class="form-input" id="sceneName" placeholder="Enter scene name" value="Scene">
      </div>
      <div class="form-group">
        <label class="form-label">Upload 360 Image</label>
        <input type="file" class="form-file" id="imageFile" accept="image/*" required>
      </div>
      <div class="btn-group">
        <button class="btn btn-secondary" id="createSceneCancel">Cancel</button>
        <button class="btn btn-primary" id="createSceneSubmit">Create Scene</button>
      </div>
    </div>
  </div>

  <!-- Manage scenes modal -->
  <div class="modal-overlay" id="manageSceneModal">
    <div class="modal">
      <div class="modal-header">
        <span>Manage Scenes</span>
        <button class="modal-close" id="manageSceneClose">✕</button>
      </div>
      <div class="manage-scenes-list" id="manageScenesList"></div>
      <div class="btn-group">
        <button class="btn btn-secondary" id="manageSceneCancel">Close</button>
      </div>
    </div>
  </div>

  <!-- Load design modal -->
  <div class="modal-overlay" id="loadDesignModal">
    <div class="modal">
      <div class="modal-header">
        <span>Load Design</span>
        <button class="modal-close" id="loadDesignClose">✕</button>
      </div>
      <div class="form-group">
        <label class="form-label">Select JSON File</label>
        <input type="file" class="form-file" id="designFile" accept=".json" required>
      </div>
      <div class="btn-group">
        <button class="btn btn-secondary" id="loadDesignCancel">Cancel</button>
        <button class="btn btn-primary" id="loadDesignSubmit">Load Design</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="remote.js"></script>
  <script>
    /* ================== SCENE DATA ================== */

    let SCENES = {
      scene1: { image: "360.jpg", name: "Scene 1", hotspots: [] },
      scene2: { image: "360-1.jpg", name: "Scene 2", hotspots: [] }
    };

    let currentScene = "scene1";

    /* ================== MODE ================== */

    let mode = "view"; // view | add | move
    let sceneSelectionMode = false;
    let selectedHotspotForScene = null;

    /* ================== REMOTE MODE ================== */
    let remoteMode = false;
    let remoteTargetScene = null;

    /* ================== THREE ================== */

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      1,
      1100
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.LinearToneMapping;
    renderer.toneMappingExposure = 2;
    document.body.appendChild(renderer.domElement);

    /* ================== SPHERES ================== */

    const geometry = new THREE.SphereGeometry(500, 64, 64);
    geometry.scale(-1, 1, 1);

    const loader = new THREE.TextureLoader();

    function createSphere(opacity) {
      return new THREE.Mesh(
        geometry,
        new THREE.MeshBasicMaterial({
          transparent: true,
          opacity: opacity
        })
      );
    }

    const sphereA = createSphere(1);
    const sphereB = createSphere(0);

    scene.add(sphereA);
    scene.add(sphereB);

    let activeSphere = sphereA;
    let inactiveSphere = sphereB;

    /* ================== HOTSPOTS ================== */

    let hotspotMeshes = [];
    const hotspotIcon = loader.load("icon.png");
    hotspotIcon.colorSpace = THREE.SRGBColorSpace;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    /* ================== LOAD SCENE (CROSS FADE) ================== */

    function loadScene(sceneKey) {
      loader.load(SCENES[sceneKey].image, tex => {
        tex.colorSpace = THREE.SRGBColorSpace;

        inactiveSphere.material.map = tex;
        inactiveSphere.material.opacity = 0;
        inactiveSphere.material.needsUpdate = true;

        let t = 0;

        function fade() {
          t += 0.02;

          inactiveSphere.material.opacity = t;
          activeSphere.material.opacity = 1 - t;

          if (t < 1) {
            requestAnimationFrame(fade);
          } else {
            activeSphere.material.opacity = 0;

            const temp = activeSphere;
            activeSphere = inactiveSphere;
            inactiveSphere = temp;

            currentScene = sceneKey;
            clearHotspots();
            createHotspots(sceneKey);
            updateRemoteVisibility();
            updateScenesList();
          }
        }

        fade();
      });
    }

    /* ================== HOTSPOT FUNCTIONS ================== */

    function createHotspots(sceneKey) {
      SCENES[sceneKey].hotspots.forEach((h, index) => {
        const mat = new THREE.MeshBasicMaterial({
          map: hotspotIcon,
          transparent: true,
          side: THREE.DoubleSide,
          depthTest: false,
          depthWrite: false
        });

        const geo = new THREE.PlaneGeometry(35, 35);
        const mesh = new THREE.Mesh(geo, mat);

        mesh.position.set(h.x, h.y, h.z);
        mesh.userData.target = h.target;
        mesh.userData.index = index;
        mesh.renderOrder = 10;

        scene.add(mesh);
        hotspotMeshes.push(mesh);
      });
    }

    function clearHotspots() {
      hotspotMeshes.forEach(h => scene.remove(h));
      hotspotMeshes = [];
    }

    function addHotspot(point, targetScene) {
      SCENES[currentScene].hotspots.push({
        x: point.x,
        y: point.y,
        z: point.z,
        target: targetScene
      });

      clearHotspots();
      createHotspots(currentScene);
    }

    function updateHotspotPosition(hotspotMesh, newPosition) {
      const hotspotIndex = hotspotMesh.userData.index;
      if (hotspotIndex !== undefined && SCENES[currentScene].hotspots[hotspotIndex]) {
        SCENES[currentScene].hotspots[hotspotIndex].x = newPosition.x;
        SCENES[currentScene].hotspots[hotspotIndex].y = newPosition.y;
        SCENES[currentScene].hotspots[hotspotIndex].z = newPosition.z;

        hotspotMesh.position.copy(newPosition);
      }
    }

    /* ================== REMOTE FUNCTIONS ================== */

    function updateRemoteModeIndicator() {
      const indicator = document.getElementById('remoteModeIndicator');
      if (remoteMode) {
        indicator.classList.add('show');
      } else {
        indicator.classList.remove('show');
      }
    }

    function handleRemotePlacement(point) {
      if (!remoteMode) return;

      // Create remote at clicked position
      RemoteModule.createRemote(point, remoteTargetScene || currentScene);

      console.log(`Remote placed at position: ${JSON.stringify(point.toArray())}`);

      // Exit remote mode after placement
      remoteMode = false;
      updateRemoteModeIndicator();
    }

    // Save design with remotes
    function saveDesignWithRemotes() {
      const designData = {
        scenes: SCENES,
        remotes: RemoteModule.getRemotesData(),
        currentScene: currentScene
      };

      const dataStr = JSON.stringify(designData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'design-data-with-remotes.json';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    // Load design with remotes
    function loadDesignWithRemotes() {
      const designFile = document.getElementById('designFile').files[0];

      if (!designFile) {
        alert('Please select a JSON file');
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const loadedData = JSON.parse(e.target.result);

          // Load scenes
          if (loadedData.scenes) {
            let isValid = true;
            for (let key in loadedData.scenes) {
              if (!loadedData.scenes[key].image || !loadedData.scenes[key].name || !Array.isArray(loadedData.scenes[key].hotspots)) {
                isValid = false;
                break;
              }
            }

            if (!isValid) {
              alert('Invalid design file format');
              return;
            }

            SCENES = loadedData.scenes;
            currentScene = loadedData.currentScene || Object.keys(SCENES)[0];
            updateScenesList();
            loadScene(currentScene);
          }

          // Load remotes
          if (loadedData.remotes && Array.isArray(loadedData.remotes)) {
            RemoteModule.loadRemotes(loadedData.remotes);
            RemoteModule.updateRemoteVisibility(currentScene);
          }

          closeLoadDesignModal();
          alert('Design with remotes loaded successfully!');
        } catch (err) {
          alert('Failed to load design: ' + err.message);
        }
      };
      reader.readAsText(designFile);
    }

    function updateRemoteVisibility() {
      RemoteModule.updateRemoteVisibility(currentScene);
    }

    /* ================== SCENE SELECTION POPUP FUNCTIONS ================== */

    function openSceneSelectionPopup(hotspotMesh) {
      selectedHotspotForScene = hotspotMesh;

      const popup = document.getElementById('sceneSelectionPopup');
      const list = document.getElementById('sceneSelectionList');

      // Clear previous list
      list.innerHTML = '';

      // Add all scenes except current one
      Object.keys(SCENES).forEach(sceneKey => {
        if (sceneKey !== currentScene) {
          const item = document.createElement('div');
          item.className = 'scene-selection-item';
          item.textContent = SCENES[sceneKey].name;
          item.dataset.sceneKey = sceneKey;

          item.addEventListener('click', () => {
            updateHotspotTarget(sceneKey);
          });

          list.appendChild(item);
        }
      });

      // Position the popup near the mouse pointer
      popup.style.left = (window.innerWidth / 2) + 'px';
      popup.style.top = (window.innerHeight / 2) + 'px';

      popup.classList.add('show');
    }

    function closeSceneSelectionPopup() {
      const popup = document.getElementById('sceneSelectionPopup');
      popup.classList.remove('show');
      selectedHotspotForScene = null;
      updateSceneSelectionIndicator();
    }

    function updateHotspotTarget(targetScene) {
      if (selectedHotspotForScene) {
        const hotspotIndex = selectedHotspotForScene.userData.index;
        if (hotspotIndex !== undefined && SCENES[currentScene].hotspots[hotspotIndex]) {
          SCENES[currentScene].hotspots[hotspotIndex].target = targetScene;
          selectedHotspotForScene.userData.target = targetScene;

          console.log(`Hotspot target updated to: ${SCENES[targetScene].name}`);

          // Show brief confirmation
          const item = document.querySelector(`[data-scene-key="${targetScene}"]`);
          if (item) {
            item.style.background = 'rgba(76, 175, 80, 0.2)';
            item.style.color = '#4CAF50';
            item.textContent = `${SCENES[targetScene].name} ✓`;

            setTimeout(() => {
              closeSceneSelectionPopup();
              // Keep scene selection mode active for more edits
            }, 1000);
          }
        }
      }
    }

    function updateSceneSelectionIndicator() {
      const indicator = document.getElementById('sceneSelectionIndicator');
      if (sceneSelectionMode) {
        indicator.classList.add('show');
      } else {
        indicator.classList.remove('show');
      }
    }

    /* ================== UI FUNCTIONS ================== */

    function updateScenesList() {
      const scenesList = document.getElementById('scenesList');
      scenesList.innerHTML = '';

      Object.keys(SCENES).forEach(sceneKey => {
        const li = document.createElement('li');
        li.className = `scene-item ${sceneKey === currentScene ? 'active' : ''}`;
        li.innerHTML = `<span class="scene-name">${SCENES[sceneKey].name}</span>`;
        li.addEventListener('click', () => {
          closeSidebar();
          loadScene(sceneKey);
        });
        scenesList.appendChild(li);
      });
    }

    function closeSidebar() {
      document.getElementById('sidebar').classList.remove('open');
      document.getElementById('hamburgerBtn').classList.remove('hidden');
    }

    function openCreateSceneModal() {
      document.getElementById('createSceneModal').classList.add('show');
    }

    function closeCreateSceneModal() {
      document.getElementById('createSceneModal').classList.remove('show');
      document.getElementById('sceneName').value = 'Scene';
      document.getElementById('imageFile').value = '';
    }

    function openManageSceneModal() {
      document.getElementById('manageSceneModal').classList.add('show');
      updateManageScenesList();
    }

    function closeManageSceneModal() {
      document.getElementById('manageSceneModal').classList.remove('show');
    }

    function openLoadDesignModal() {
      document.getElementById('loadDesignModal').classList.add('show');
    }

    function closeLoadDesignModal() {
      document.getElementById('loadDesignModal').classList.remove('show');
      document.getElementById('designFile').value = '';
    }

    function updateManageScenesList() {
      const manageList = document.getElementById('manageScenesList');
      manageList.innerHTML = '';

      if (Object.keys(SCENES).length === 0) {
        manageList.innerHTML = '<div class="no-scenes-message">No scenes created yet</div>';
        return;
      }

      Object.keys(SCENES).forEach(sceneKey => {
        const sceneData = SCENES[sceneKey];
        const div = document.createElement('div');
        div.className = 'manage-scene-item';
        div.id = `manage-${sceneKey}`;

        div.innerHTML = `
      <div class="manage-scene-info">
        <div class="manage-scene-name" data-scene-key="${sceneKey}" data-editing="false">
          ${sceneData.name}
        </div>
        <input type="text" class="manage-scene-input" style="display:none;" value="${sceneData.name}" data-scene-key="${sceneKey}">
      </div>
      <div class="manage-scene-actions">
        <button class="btn-small btn-small-rename" data-action="rename" data-scene-key="${sceneKey}">Rename</button>
        <button class="btn-small btn-small-delete" data-action="delete" data-scene-key="${sceneKey}" ${Object.keys(SCENES).length === 1 ? 'disabled' : ''}>Delete</button>
      </div>
    `;

        manageList.appendChild(div);
      });

      manageList.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', handleManageAction);
      });
    }

    function handleManageAction(e) {
      const action = e.target.dataset.action;
      const sceneKey = e.target.dataset.sceneKey;

      if (action === 'rename') {
        const nameDiv = document.querySelector(`[data-scene-key="${sceneKey}"][data-editing="false"]`);
        const input = document.querySelector(`input[data-scene-key="${sceneKey}"]`);

        if (nameDiv && input) {
          nameDiv.style.display = 'none';
          input.style.display = 'block';
          input.focus();
          e.target.textContent = 'Save';
          e.target.dataset.action = 'save-rename';
        }
      } else if (action === 'save-rename') {
        const input = document.querySelector(`input[data-scene-key="${sceneKey}"]`);
        const newName = input.value.trim();

        if (newName) {
          SCENES[sceneKey].name = newName;
          const nameDiv = document.querySelector(`[data-scene-key="${sceneKey}"][data-editing="false"]`);
          nameDiv.textContent = newName;
          nameDiv.style.display = 'block';
          input.style.display = 'none';
          e.target.textContent = 'Rename';
          e.target.dataset.action = 'rename';
          updateScenesList();
        }
      } else if (action === 'delete') {
        if (confirm(`Are you sure you want to delete "${SCENES[sceneKey].name}"?`)) {
          delete SCENES[sceneKey];

          if (currentScene === sceneKey) {
            currentScene = Object.keys(SCENES)[0];
            loadScene(currentScene);
          }

          updateManageScenesList();
          updateScenesList();
        }
      }
    }

    function createNewScene() {
      const sceneName = document.getElementById('sceneName').value.trim();
      const imageFile = document.getElementById('imageFile').files[0];

      if (!sceneName || !imageFile) {
        alert('Please enter a scene name and select an image');
        return;
      }

      let sceneKey = `scene${Date.now()}`;

      const reader = new FileReader();
      reader.onload = (e) => {
        SCENES[sceneKey] = {
          image: e.target.result,
          name: sceneName,
          hotspots: []
        };

        updateScenesList();
        closeCreateSceneModal();
        loadScene(sceneKey);
      };
      reader.readAsDataURL(imageFile);
    }

    /* ================== EVENT LISTENERS FOR MODALS ================== */

    /* Improved hamburger button with touch support */
    document.getElementById('hamburgerBtn').addEventListener('click', (e) => {
      e.preventDefault();
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('open');
      if (sidebar.classList.contains('open')) {
        document.getElementById('hamburgerBtn').classList.add('hidden');
      }
    });

    document.getElementById('hamburgerBtn').addEventListener('touchend', (e) => {
      e.preventDefault();
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('open');
      if (sidebar.classList.contains('open')) {
        document.getElementById('hamburgerBtn').classList.add('hidden');
      }
    });

    document.getElementById('sidebarClose').addEventListener('click', closeSidebar);
    document.getElementById('sidebarClose').addEventListener('touchend', closeSidebar);

    document.getElementById('createSceneClose').addEventListener('click', closeCreateSceneModal);
    document.getElementById('createSceneCancel').addEventListener('click', closeCreateSceneModal);
    document.getElementById('createSceneSubmit').addEventListener('click', createNewScene);

    document.getElementById('manageSceneClose').addEventListener('click', closeManageSceneModal);
    document.getElementById('manageSceneCancel').addEventListener('click', closeManageSceneModal);

    document.getElementById('loadDesignClose').addEventListener('click', closeLoadDesignModal);
    document.getElementById('loadDesignCancel').addEventListener('click', closeLoadDesignModal);
    document.getElementById('loadDesignSubmit').addEventListener('click', loadDesignWithRemotes);

    document.getElementById('sceneName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') createNewScene();
    });

    document.getElementById('sceneSelectionClose').addEventListener('click', closeSceneSelectionPopup);

    // Close popup when clicking outside - BUT prevent immediate closing
    let popupClickTime = 0;
    document.addEventListener('mousedown', (e) => {
      const popup = document.getElementById('sceneSelectionPopup');
      if (popup.classList.contains('show') &&
        !popup.contains(e.target) &&
        e.target !== document.getElementById('sceneSelectionClose')) {
        // Only close if not just opened (prevent immediate closing)
        const now = Date.now();
        if (now - popupClickTime > 100) {
          closeSceneSelectionPopup();
        }
      }
    });

    // Track when popup opens
    const originalOpenSceneSelectionPopup = openSceneSelectionPopup;
    openSceneSelectionPopup = function (hotspotMesh) {
      popupClickTime = Date.now();
      return originalOpenSceneSelectionPopup.call(this, hotspotMesh);
    };

    /* ================== KEY CONTROLS ================== */

    const keys = new Set();

    document.addEventListener("keydown", e => {
      keys.add(e.key.toLowerCase());

      // Remote placement mode - s + r
      if (keys.has("s") && keys.has("r")) {
        if (!remoteMode) {
          remoteMode = true;
          remoteTargetScene = currentScene;
          updateRemoteModeIndicator();
          console.log("Remote placement mode ACTIVATED for scene: " + SCENES[currentScene].name);
        }
        mode = "view";
        sceneSelectionMode = false;
        updateSceneSelectionIndicator();
      }

      // Deactivate remote mode with m + d (same as other modes)
      if (keys.has("m") && keys.has("d")) {
        if (remoteMode) {
          remoteMode = false;
          updateRemoteModeIndicator();
          console.log("Remote placement mode DEACTIVATED.");
        }
        if (sceneSelectionMode) {
          sceneSelectionMode = false;
          updateSceneSelectionIndicator();
          console.log("Scene selection mode DEACTIVATED.");
        }
        mode = "view";
      }

      // Scene selection mode activation - n + e together (TOGGLE)
      if (keys.has("n") && keys.has("e")) {
        if (!sceneSelectionMode && !remoteMode) {
          sceneSelectionMode = true;
          mode = "view";
          updateSceneSelectionIndicator();
          console.log("Scene selection mode ACTIVATED. Click on a hotspot to select target scene.");
        }
      }

      // Existing mode controls (deactivate other modes when entering new mode)
      if (keys.has("n") && keys.has("b")) {
        sceneSelectionMode = false;
        updateSceneSelectionIndicator();
        remoteMode = false;
        updateRemoteModeIndicator();
        mode = "add";
      }
      if (keys.has("m") && keys.has("e")) {
        sceneSelectionMode = false;
        updateSceneSelectionIndicator();
        remoteMode = false;
        updateRemoteModeIndicator();
        mode = "move";
      }

      if (keys.has("i") && keys.has("m") && keys.has("u")) {
        e.preventDefault();
        openCreateSceneModal();
      }

      if (keys.has("i") && keys.has("m") && keys.has("r")) {
        e.preventDefault();
        openManageSceneModal();
      }

      if (keys.has("s") && keys.has("d")) {
        e.preventDefault();
        saveDesignWithRemotes();
      }

      if (keys.has("l") && keys.has("d")) {
        e.preventDefault();
        openLoadDesignModal();
      }
    });

    document.addEventListener("keyup", e => {
      const key = e.key.toLowerCase();
      keys.delete(key);

      // DON'T automatically disable sceneSelectionMode when keys are released
      // The mode stays active until explicitly turned off with m+d or entering another mode
    });

    /* ================== POINTER (MOUSE + TOUCH) ================== */

    let isDown = false;
    let isTouch = false;
    let startX = 0, startY = 0;
    let selectedHotspot = null;
    let hotspotMoveStartPosition = null;
    let preventHotspotClick = false;

    function getClientCoordinates(event) {
      if (event.touches) {
        return {
          clientX: event.touches[0].clientX,
          clientY: event.touches[0].clientY
        };
      } else {
        return {
          clientX: event.clientX,
          clientY: event.clientY
        };
      }
    }

    function setMouseFromEvent(e) {
      const coords = getClientCoordinates(e);
      mouse.x = (coords.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(coords.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
    }

    function handlePointerStart(e) {
      e.preventDefault();
      isDown = true;
      isTouch = e.type === 'touchstart';

      const coords = getClientCoordinates(e);
      startX = coords.clientX;
      startY = coords.clientY;

      setMouseFromEvent(e);

      // Check for remote placement
      if (remoteMode) {
        const hit = raycaster.intersectObject(activeSphere);
        if (hit.length) {
          handleRemotePlacement(hit[0].point);
          return;
        }
      }

      // Check if we're in scene selection mode
      if (sceneSelectionMode) {
        preventHotspotClick = true;
        const hit = raycaster.intersectObjects(hotspotMeshes);
        if (hit.length) {
          setTimeout(() => {
            openSceneSelectionPopup(hit[0].object);
          }, 10);
          return;
        }
      }

      if (mode === "view" && !sceneSelectionMode) {
        const hit = raycaster.intersectObjects(hotspotMeshes);
        if (hit.length) {
          loadScene(hit[0].object.userData.target);
          return;
        }
      }

      if (mode === "add") {
        if (!isTouch) {
          const hit = raycaster.intersectObject(activeSphere);
          if (hit.length) {
            const sceneKeys = Object.keys(SCENES);
            const currentIndex = sceneKeys.indexOf(currentScene);
            const target = sceneKeys[(currentIndex + 1) % sceneKeys.length];
            addHotspot(hit[0].point, target);
            mode = "view";
          }
        }
        return;
      }

      if (mode === "move") {
        const hit = raycaster.intersectObjects(hotspotMeshes);
        if (hit.length) {
          selectedHotspot = hit[0].object;
          hotspotMoveStartPosition = selectedHotspot.position.clone();
        }
      }
    }

    function handlePointerMove(e) {
      if (!isDown) return;
      e.preventDefault();

      const coords = getClientCoordinates(e);
      const dx = coords.clientX - startX;
      const dy = coords.clientY - startY;

      if (mode === "view" || sceneSelectionMode) {
        lon -= dx * 0.1;
        lat += dy * 0.1;
      }

      if (mode === "move" && selectedHotspot) {
        setMouseFromEvent(e);
        const hit = raycaster.intersectObject(activeSphere);
        if (hit.length) {
          selectedHotspot.position.copy(hit[0].point);
        }
      }

      startX = coords.clientX;
      startY = coords.clientY;
    }

    function handlePointerEnd(e) {
      e.preventDefault();

      if (mode === "move" && selectedHotspot) {
        if (!selectedHotspot.position.equals(hotspotMoveStartPosition)) {
          updateHotspotPosition(selectedHotspot, selectedHotspot.position);
        }
      }

      isDown = false;
      selectedHotspot = null;
      hotspotMoveStartPosition = null;
      isTouch = false;
      preventHotspotClick = false;
    }

    document.addEventListener("mousedown", handlePointerStart);
    document.addEventListener("mousemove", handlePointerMove);
    document.addEventListener("mouseup", handlePointerEnd);

    let touchStartTime = 0;
    let touchStartX = 0;
    let touchStartY = 0;

    document.addEventListener("touchstart", function (e) {
      e.preventDefault();

      const touch = e.touches[0];
      touchStartTime = Date.now();
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;

      mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      // For touch, don't use scene selection mode (simpler)
      const hit = raycaster.intersectObjects(hotspotMeshes);
      if (hit.length) {
        loadScene(hit[0].object.userData.target);
        return;
      }

      isDown = true;
      startX = touch.clientX;
      startY = touch.clientY;
    }, { passive: false });

    document.addEventListener("touchmove", function (e) {
      if (!isDown) return;
      e.preventDefault();

      const touch = e.touches[0];
      const dx = touch.clientX - startX;
      const dy = touch.clientY - startY;

      lon -= dx * 0.1;
      lat += dy * 0.1;

      startX = touch.clientX;
      startY = touch.clientY;
    }, { passive: false });

    document.addEventListener("touchend", function (e) {
      e.preventDefault();

      const touchTime = Date.now() - touchStartTime;
      const touch = e.changedTouches[0];
      const dx = Math.abs(touch.clientX - touchStartX);
      const dy = Math.abs(touch.clientY - touchStartY);

      if (touchTime < 300 && dx < 10 && dy < 10) {
        // Already handled in touchstart for hotspots
      }

      isDown = false;
    }, { passive: false });

    document.addEventListener("contextmenu", e => e.preventDefault());

    /* ================== CAMERA ================== */

    let lon = 0, lat = 0;

    function animate() {
      requestAnimationFrame(animate);

      lat = Math.max(-85, Math.min(85, lat));
      const phi = THREE.MathUtils.degToRad(90 - lat);
      const theta = THREE.MathUtils.degToRad(lon);

      camera.lookAt(
        500 * Math.sin(phi) * Math.cos(theta),
        500 * Math.cos(phi),
        500 * Math.sin(phi) * Math.sin(theta)
      );

      hotspotMeshes.forEach(h => h.lookAt(camera.position));

      // UPDATE REMOTE POSITIONS EVERY FRAME
      RemoteModule.updateRemotePositions(camera);

      renderer.render(scene, camera);
    }

    /* ================== INIT ================== */

    loader.load(SCENES[currentScene].image, tex => {
      tex.colorSpace = THREE.SRGBColorSpace;
      activeSphere.material.map = tex;
      activeSphere.material.needsUpdate = true;
    });

    createHotspots(currentScene);
    updateScenesList();
    animate();

    /* ================== RESIZE ================== */

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Close remote modal when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.remote-modal-content') &&
        !e.target.closest('.remote-main-button') &&
        !e.target.closest('.remote-close-btn')) {
        document.querySelectorAll('.remote-main-button').forEach(btn => {
          btn.classList.remove('active-main');
        });
      }
    });
  </script>

</body>

</html>